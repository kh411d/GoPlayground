package main

import (
	"crypto/rand"
	"errors"
	"fmt"
	"io"
	"math/big"
)

var P *big.Int //Big Prime
var G *big.Int //Generator

func init() {
	//Default Prime and Generator
	P, _ = new(big.Int).SetString("FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3DC2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F83655D23DCA3AD961C62F356208552BB9ED529077096966D670C354E4ABC9804F1746C08CA18217C32905E462E36CE3BE39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9DE2BCBF6955817183995497CEA956AE515D2261898FA051015728E5A8AAAC42DAD33170D04507A33A85521ABDF1CBA64ECFB850458DBEF0A8AEA71575D060C7DB3970F85A6E1E4C7ABF5AE8CDB0933D71E8C94E04A25619DCEE3D2261AD2EE6BF12FFA06D98A0864D87602733EC86A64521F2B18177B200CBBE117577A615D6C770988C0BAD946E208E24FA074E5AB3143DB5BFCE0FD108E4B82D120A93AD2CAFFFFFFFFFFFFFFFF", 16)
	G = big.NewInt(2)
}

func main() {
	// priv, pub, err := gr.GenerateKey(rand.Reader)
	// fmt.Println(err)
	// fmt.Printf("AlicePriv : %s\n", priv.String())
	// fmt.Printf("AlicePub : %s\n", pub.String())
	priv, _ := new(big.Int).SetString("2245664682890339219369376843486945925841488795008884830491129134732703391782639176346528316124723266806303378260702982108136804439009116887026848855324420138247568080836211349749890731543286732918657323261027881280023299166926068258016247980982859687338254004910986415495888993636304540920445596153306872779903171512343601710939713465356723603290944724562647324971008108443573599879094351561265626287738114265412820830306047668020147030207112162904964952227759198384078971534785440784791309806242625366548962698592800793624317536893572021371786096071306218297348202433212439680998975434036124206554486886942207236657928177609881781085633063727733452195255530367660245333416949509175287982603009500352881525943775765674151650695063204537367847682802550200372836674411946758196908062728917886609135789519283778991945684103238541030260911000334047314088202241187240361651605276940009745573457817693318307002223688918735374662", 10)
	peerPub, _ := new(big.Int).SetString("1136021944150800643080020607805793802429592090056038330534495322510423548099524657989793017996065610927339188743180291432884255086019383860566900733378987550479775804730795291957685301439964623445265582547836713109259971192974047944297242800888600192020528904950010817314480053426951690951291327844287695617814241282033574760707053290958124461711586721355550606064528704110853026655014703268849839737108773238628138404240469313195709597594856364432198625621342005557923322292116735230758654444440206462485989430286992334322033024300564143598110200984829286360718976104077729847557549174149526419099919296270854658709258187548938397752429162869027215321573230655956157608712723072000351364071904626931916753078293098474613835097042496179892262732501488501838461276410570741829228256989042834867677955352678682936710165619981206338189911564443947668561739290078073266985371712914893131047153176692775994975314307274500980797659", 10)

	err := Check(peerPub)
	fmt.Println(err)
	x := ComputeSecret(priv, peerPub)

	fmt.Printf("secret : %s\n", x.String())
}

// IsSafePrime returns true, if the prime of the group is
// a so called safe-prime. For a group with a safe-prime prime
// number the Decisional-Diffie-Hellman-Problem (DDH) is a
// 'hard' problem. The n argument is the number of iterations
// for the probabilistic prime test.
// It's recommend to use DDH-safe groups for DH-exchanges.
func IsSafePrimeGroup(n int) bool {
	q := new(big.Int).Sub(P, big.NewInt(1))
	q = q.Div(q, big.NewInt(2))
	return q.ProbablyPrime(n)
}

// GenerateKey generates a public/private key pair using entropy from rand.
// If rand is nil, crypto/rand.Reader will be used.
func GenerateKey(random io.Reader) (private *big.Int, public *big.Int, err error) {
	if random == nil {
		random = rand.Reader
	}

	// Ensure, that p.G ^ privateKey > than g.P
	// (only modulo calculations are safe)
	// The minimal (and common) value for p.G is 2
	// So 2 ^ (1 + 'bitsize of p.G') > than g.P
	min := big.NewInt(int64(P.BitLen() + 1))
	bytes := make([]byte, (P.BitLen()+7)/8)

	for private == nil {
		_, err = io.ReadFull(random, bytes)
		if err != nil {
			private = nil
			return
		}
		// Clear bits in the first byte to increase
		// the probability that the candidate is < g.P.
		bytes[0] = 0
		if private == nil {
			private = new(big.Int)
		}
		(*private).SetBytes(bytes)
		if (*private).Cmp(min) < 0 {
			private = nil
		}
	}

	public = new(big.Int).Exp(G, private, P)
	return
}

// PublicKey returns the public key corresponding to the given private one.
func PublicKey(private *big.Int) (public *big.Int) {
	public = new(big.Int).Exp(G, private, P)
	return
}

//private returns a non-nil error if the given public key is
// not a possible element of the group. This means, that the
// public key is < 0 or > g.P.
func Check(peersPublic *big.Int) (err error) {
	if !((*peersPublic).Cmp(big.NewInt(0)) >= 0 && (*peersPublic).Cmp(P) == -1) {
		err = errors.New("peer's public is not a possible group element")
	}
	return
}

// ComputeSecret returns the secret computed from
// the own private and the peer's public key.
func ComputeSecret(private *big.Int, peersPublic *big.Int) (secret *big.Int) {
	secret = new(big.Int).Exp(peersPublic, private, P)
	return
}
