package main

import (
	"crypto/rand"
	"fmt"
	"math/big"
)

func main() {

	x := NewDH()

	Apriv, err := x.GeneratePrivateKey()
	fmt.Println(err)
	Apub := x.GeneratePublicKey(Apriv)

	fmt.Printf("AlicePriv: %s\n", Apriv.String())
	fmt.Printf("AlicePub: %s\n", Apub.String())

	// Apriv := new(big.Int)
	// Apriv.SetString("2032952758558780086248586717142036716899534025053356685258523089220833276101388311947907524", 10)

	// Apub := new(big.Int)
	// Apub.SetString("3534336896354875086793987470370133426901917199488922797187182526981779217668060722065167362316673461635229919515767663080353271803643823463430721392631106727563811852366093488858650948777722036723423358189969895650101702302283589124908880236538068656395037512782349330129859561476962680616215450205195293287055495551887023927662593755798414211304743709075467076818507165677863408954338143842071741409585172404305674216843150594070110359136672498689458662850969879702037021521729582782749641741647711954681659129363101997219982091448052352487326616546174364662761600646984324671070305706166869223386706484457037062769899725375779834653515711257773400689499142105056181724001585806626481587158047786296293290409155223776055673516406736842302751143673588106896377678994753554099159763549934650000853516468143978828720952717614627318832950329728708929198945218027077472022625042554712401189350245210080814019836509381843879441126", 10)

	// Bpub := new(big.Int)
	// Bpub.SetString("4038648433116865196545362083496565812604080082738680595134532759470829448549887551610431925631166312923809104354137263391306447297018841822950230885776402328827475910974486186855870093126064754920955706017488682665422173044720382448925156931316980437284113116559211115900267510786980021375377516520763654619030263428558123215003887163693031996490305632086889225545210666386385990824034523654764086937946214346307319874237197300916201674031659548519738362291282381942701757015064820471673419086261938915607901102153011670819253572151927399085811378749738328011316830012403406267834974762224224725887521188518298567339552373636587087793556916217798050895164173627639953319384187041122579029973028836762693585956015469726541452196575235805615552600184382818466332179179940457654498001001952371269138330246328673147110024931077171754211649764854820541383376759347612013728803112262026240602749675433446240589416316456173010389837", 10)

	// Asec := x.GenerateSharedKey(Apriv, Bpub)
	// fmt.Printf("A Secret : %s\n", Asec.String())

	y := NewDH()

	Bpriv, err := y.GeneratePrivateKey()
	fmt.Println(err)
	Bpub := y.GeneratePublicKey(Bpriv)

	fmt.Printf("BobPriv: %s\n", Bpriv.String())
	fmt.Printf("BobPub: %s\n", Bpub.String())

	Asec := x.GenerateSharedKey(Apriv, Bpub)
	Bsec := y.GenerateSharedKey(Bpriv, Apub)

	fmt.Printf("A Secret : %s\n", Asec.String())
	fmt.Printf("B Secret : %s\n", Bsec.String())

}

type dh struct {
	P *big.Int
	G *big.Int
}

func NewDH() *dh {
	P := new(big.Int)
	P.SetString("FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3DC2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F83655D23DCA3AD961C62F356208552BB9ED529077096966D670C354E4ABC9804F1746C08CA18217C32905E462E36CE3BE39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9DE2BCBF6955817183995497CEA956AE515D2261898FA051015728E5A8AAAC42DAD33170D04507A33A85521ABDF1CBA64ECFB850458DBEF0A8AEA71575D060C7DB3970F85A6E1E4C7ABF5AE8CDB0933D71E8C94E04A25619DCEE3D2261AD2EE6BF12FFA06D98A0864D87602733EC86A64521F2B18177B200CBBE117577A615D6C770988C0BAD946E208E24FA074E5AB3143DB5BFCE0FD108E4B82D120A93AD2CAFFFFFFFFFFFFFFFF", 16)
	G := big.NewInt(2)

	return &dh{
		P: P,
		G: G,
	}
}

func (d *dh) GeneratePublicKey(privateKey *big.Int) *big.Int {
	r := new(big.Int)
	r.Exp(d.G, privateKey, d.P)
	return r
}

func (d *dh) GeneratePrivateKey() (*big.Int, error) {
	max := new(big.Int)
	max.Exp(big.NewInt(2), big.NewInt(500), nil).Sub(max, big.NewInt(1))

	//Generate cryptographically strong pseudo-random between 0 - max
	n, err := rand.Int(rand.Reader, max)
	if err != nil {
		return nil, err
	}

	return n, nil
}

func (d *dh) GenerateSharedKey(privateKey, publicKey *big.Int) *big.Int {
	r := new(big.Int)
	r.Exp(publicKey, privateKey, d.P)
	return r
}
